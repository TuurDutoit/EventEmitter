{"name":"Eventemitter","tagline":"The last EventEmitter you'll ever need. Small, fast, full-featured, for node.js and the browser.","body":"EventEmitter\r\n============\r\n\r\nThe last EventEmitter you'll ever need. Small, fast, full-featured, for node.js and the browser.  \r\nApart from the usual stuff, `EventEmitter` features:\r\n1. `handleEvent()` objects\r\n2. wildcards\r\n3. namespaces\r\n4. an API you already know\r\n5. excellent documentation\r\n6. extensive tests, powered by [Jasmine (v2.1)][jasmine]\r\n7. support for your package manager\r\n\r\nAnd all this in 3.2kB (minified) or 1067 bytes (gzipped)!\r\n\r\n\r\n## Table of Contents\r\n* [Getting a copy](#getting-a-copy)\r\n    * [Source](#source)\r\n    * [NPM](#npm)\r\n    * [Bower](#bower)\r\n    * [Component](#component)\r\n* [Using it in your page](#using-it-in-your-page)\r\n    * [Browser](#browser)\r\n    * [AMD](#amd)\r\n    * [node.js / CommonJS](#nodejs--commonjs)\r\n* [Contributing](#contributing)\r\n* [Notes](#notes)\r\n    * [Wildcards](#wildcards)\r\n    * [Listeners](#listeners)\r\n* [API](#api)\r\n    * [new EventEmitter()](#new-eventemitter)\r\n    * [#_events](#_events--object)\r\n    * [#on/addListener/addEventListener](#onaddlisteneraddeventlistener-string-event-listener-listener)\r\n    * [#once/addOnceListener](#onceaddoncelistener-string-event-listener-listener)\r\n    * [#many/addManyListener](#manyaddmanylistener-string-event-listener-listener-int-times)\r\n    * [#emit/fire/trigger](#emitfiretrigger-string-event-any-arg1-any-arg2)\r\n    * [#off/removeListener/removeEventListener](#offremovelistenerremoveeventlistener-string-event-listener-listener-bool-all-false)\r\n    * [#offAll/removeAllListeners](#offallremovealllisteners-string-event-)\r\n    * [#count/countListeners](#countcountlisteners-string-event-)\r\n    * [#listeners/getListeners](#listenersgetlisteners-string-event-)\r\n    * [#namespace](#namespace-string-scope)\r\n    * [.Namespace](#EventEmitter-emitter-string-scope)\r\n    * [.execListener](#execlistener-listener-listener-arrayany-args)\r\n    * [.eventRegexp](#eventregexp-string-event)\r\n    * [.regexps](#regexps--object)\r\n* [License](#license)\r\n\r\n\r\n## Getting a copy\r\nThere are several ways of obtaining a copy of `EventEmitter`. You can download the source code from [GitHub], or use your preferred package manager.\r\n\r\n### Source\r\nGo to the [GitHub repo][GitHub], download the `EventEmitter.js` or `EventEmitter.min.js` (minified) scripts and put them somewhere in your project folder.\r\n\r\n### NPM\r\nMake sure you have [node.js] and [npm][npm-home] (which comes with node.js) installed. Then, you can just:\r\n\r\n```\r\n$ npm install --save last-eventemitter\r\n```\r\n\r\n### Bower\r\nMake sure you have [Bower][bower-home] installed. Then, you can just:\r\n\r\n```\r\n$ bower install TuurDutoit/EventEmitter\r\n```\r\n\r\n### Component\r\nMake sure you have [Component][component-home] installed. Then, you can just:\r\n\r\n```\r\n$ component install TuurDutoit/EventEmitter\r\n```\r\n\r\n\r\n## Using it in your page\r\nAgain, there are several ways to do this. `EventEmitter` works with AMD loaders (like [requirejs]), commonJS (used by [node.js]) and in the browser, as the global `EventEmitter` symbol.\r\n\r\n### Browser\r\nJust include the `EventEmitter.js` (developement) or `EventEmitter.min.js` (production) scripts in your page, by appending a `<script>` tag in the `<head>`:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"path/to/EventEmitter.js\"></script>\r\n```\r\n\r\n### AMD\r\nJust require it in your code, like so:\r\n\r\n```javascript\r\n//myModule.js\r\ndefine(\"path/to/EventEmitter\", function(EventEmitter) {...});\r\n```\r\n\r\nNote the absence of the `.js` extension on `path/to/EventEmitter`!\r\n\r\n### node.js / commonJS\r\nJust require it in your code, like so:\r\n\r\n```javascript\r\nvar EventEmitter = require(\"last-eventemitter\");\r\n```\r\n\r\nNote the absence of the `.js` extension on `path/to/EventEmitter`!\r\n\r\n\r\n## Contributing\r\n`EventEmitter` is fully open-source and free as in speech. Please feel free to open issues (in the [issue tracker] please) and don't be shy to open a Pull Request! Happy coding!\r\n\r\n\r\n## Notes\r\n### Wildcards\r\nAt the moment the wildcards implementation works with RegExps, which have one major downside: comparing two RegExps (and thus wildcard events) is very difficult. That is why I advise you to use wildcards only with namespaces: use them to wildcard scopes, but not parts of scopes/events. That leads to problems when matching event strings.\r\n\r\nAlso, wildcards work differently with `#off()` and `#offAll()` than with all the other methods. With `#off()` and `#offAll()`, the `event`s passed to those methods are converted to RegExps, and then all the listeners' event strings are matched against these RegExps to determine which should be removed. This prevents the removal of a listener listening to `scope:*` by calling `#offAll(\"scope:event\")`, but allows removing a listener listening for `scope:event` byt calling `#offAll(\"scope:*\")`.  \r\nWith all the other methods, it works a little differently. Here, matches are tested in both ways: the listeners' event strings are matched against the `event`s RegExp, and the `event` is tested against the listeners' RegExps. This allows executing a listener listening to `scope:*` with a call to `emit(\"scope:event\")`, but it also allows executing one listening to `scope:event` by calling `emit(\"scope:*\")`.\r\n\r\nI'm working on a way to allow for more complex wildcards, maybe even using RegExps yourself in all the methods, but that is complex, and more importantly, computationally intensive, and thus slow. I hope I can solve the problem, but don't expect that to happen soon.\r\n\r\n\r\n### Listeners\r\n`Listener`s can be either a normal `function` or an object with a `handleEvent()` method (as in the DOM Events API). For more info about `handleEvent()`, check [this page][handleEvent] (check the 'listener' section).  \r\n\r\n\r\n## API\r\n\r\n__Note__: A `.` means a property/method is only available on the `EventEmitter` object, not on its instances. A `#` means that a property/method is only available on `EventEmitter` instances.\r\n\r\n__Note__: A `Listener` type means either a normal function or an Object with a `handleEvent()` method. For more info, check the [Listeners](#listeners) section above.\r\n\r\n\r\n### new EventEmitter()\r\n__*return*__: *EventEmitter*. Of course.\r\n\r\nTo begin, create a new instance of `EventEmitter`. The contructor doesn't expect any arguments.\r\n\r\n```javascript\r\nvar ee = new EventEmitter();\r\n```\r\n\r\n\r\n### #_events | Object\r\nThe `#_events`object maps event strings to arrays of listeners. It is intended to be used internally, but you can, very cautiously, use it yourself.\r\n\r\nAn `_events` object looks like this:\r\n```javascript\r\nee._events = {\r\n    \"event\": [function(){...}, function(){...}, function(){...}],\r\n    \"scope:event\": [function(){...}],\r\n    \"scope:*\": [function(){...}, function(){...}]\r\n}\r\n```\r\n\r\n\r\n### #on/addListener/addEventListener (string: event, Listener: listener)\r\n__event__: *string*. The event to add the listener to. May contain wildcards.  \r\n__listener__: *Listener*. The listener to add.  \r\n__*return*__: *EventEmitter*. For chaining.\r\n\r\nUse this method to attach an event listener. When the `event` is fired, the listener will be executed (i.e. passed to `EventEmitter.execListener`) and the arguments passed to `emit()` will be passed on to the listener. The last argument will be the event string passed to `emit()`. If a listener is added multiple times, it will be executed the same amount of times it was added and in the same order as it was added. Also, `event` may contain wildcards (please read the [Wildcards](#wildcards) section).\r\n\r\n```javascript\r\n// Received event: scope:event\r\n// Hello, Tuur Dutoit\r\nee.on(\"event\", function(name, event) {\r\n    console.log(\"Hello, \" + name);\r\n});\r\nee.on(\"scope:*\", function(event) {\r\n    console.log(\"Received event: \" + event);\r\n});\r\n\r\nee.emit(\"scope:event\");\r\nee.emit(\"event\", \"Tuur Dutoit\");\r\n```\r\n\r\n\r\n### #once/addOnceListener (string: event, Listener: listener)\r\n__event__: *string*. The event to add the listener to. May contain wildcards.  \r\n__listener__: *Listener*. The listener to add.  \r\n__*return*__: *EventEmitter*. For chaining.\r\n\r\nThis method does the same as `#on()`, but it makes sure the listener is only called once: it will remove it after the first call.\r\n\r\n```javascript\r\n// Listener called 1 time.\r\n// Done.\r\nvar count = 0;\r\nee.once(\"event\", function() {\r\n    count++;\r\n    console.log(\"Listener called \" + count + \" time.\");\r\n});\r\n\r\nee.emit(\"event\");\r\nee.emit(\"event\");\r\nconsole.log(\"Done.\");\r\n```\r\n\r\n\r\n### #many/addManyListener (string: event, Listener: listener, int: times)\r\n__event__: *string*. The event to add the listener to. May contain wildcards.  \r\n__listener__: *Listener*. The listener to add.  \r\n__times__: *int*. The maximum amount of times to call the listener.  \r\n__*return*__: *EventEmitter*. For chaining.\r\n\r\nThis method does the same as `#on()`, but makes sure the listener is called a maximum of `times` times, by removing the listener after the `times`th call.\r\n\r\n__Note__: `addManyListener` is singular!\r\n\r\n```javascript\r\n// Listener called 1 times.\r\n// Listener called 2 times.\r\n// Done.\r\nvar count = 0;\r\nee.many(\"event\", function() {\r\n    count++;\r\n    console.log(\"Listener called \" + count + \" times.\");\r\n}, 2);\r\n\r\nee.emit(\"event\");\r\nee.emit(\"event\");\r\nee.emit(\"event\");\r\nconsole.log(\"Done.\");\r\n```\r\n\r\n\r\n### #emit/fire/trigger (string: event, [any: arg1, any: arg2,...])\r\n__event__: *string*. The event that should be emitted. May contain wildcards.  \r\n__argN__: *any*. Arguments to pass to the listeners.  \r\n__*return*__: *EventEmitter*. For chaining.\r\n\r\nThis method emits events, i.e. it executes all the listeners that are listening for `event` (which may contain wildcards; read the [Wildcards](#wildcards) section), passing in all the arguments after `event`.  \r\nThere are two things happening here:\r\n1. Checking which listeners to call. This is done by checking if the `event` RegExp matches the listener's event string, __or vice versa__. Read the [Wildcards](#wildcards) section for more info.\r\n2. Executing the listeners. In this stage, all the matching listeners are passed to `.execListener()` for execution. The `args` will be set to any arguments that are passed after `event`, and then `event` itself is passed as last argument.\r\n\r\n```javascript\r\n// Received event: scope:event\r\n// Hello, Tuur Dutoit\r\nee.on(\"event\", function(name, event) {\r\n    console.log(\"Hello, \" + name);\r\n});\r\nee.on(\"scope:*\", function(event) {\r\n    console.log(\"Received event: \" + event);\r\n});\r\n\r\nee.emit(\"scope:event\");\r\nee.emit(\"event\", \"Tuur Dutoit\");\r\n```\r\n\r\n### #off/removeListener/removeEventListener (string: event, Listener: listener, [bool: all (false)])\r\n__event__: *string*. The event to remove the listener from. May contain wildcards.  \r\n__listener__: *Listener*. The listener to remove.  \r\n__all__: *bool, optional (false)*. Whether to remove all instances of the listener.  \r\n__*return*__: *EventEmitter*. For chaining.\r\n\r\nThis method removes `listener` from the list of listeners for `event`. `event` may contain wildcards, but these work a little different from `#on()` and `#emit()`: here, only the listeners' event strings are matched against `event`'s RegExp, and not the other way around. For more info, read the [Wildcards](#wildcards) section.  \r\nThe `all` argument allows to control the behaviour when a listener has been added multiple times. When `all` is `false` (the default), only one instance of the listener is removed. When `all` is `true`, all the instances (that match `event`) will be removed.\r\n\r\nWith `all = false`:\r\n```javascript\r\nvar listener = function(){...};\r\n// Add the listener twice\r\nee.on(\"event\", listener);\r\nee.on(\"event\", listener);\r\n// Remove one instance\r\nee.off(\"event\", listener);\r\n// 1\r\nee.count(\"event\");\r\n```\r\nWith `all = true`:\r\n```javascript\r\nee.on(\"event\", listener);\r\nee.on(\"event\", listener);\r\n// Remove all instances\r\nee.off(\"event\", listener, true);\r\n// 0\r\nee.count(\"event\");\r\n```\r\n\r\n\r\n### #offAll/removeAllListeners ([string: event (\"*\")])\r\n__event__: _string, optional (\"*\")_. The event to remove all listeners from. May contain wildcards.  \r\n__*return*__: *EventEmitter*. For chaining.\r\n\r\nThis method removes all listeners for a specific `event` (which may contain wildcards; read the [Wildcards](#wildcards) section), or for the whole `EventEmitter` (if no `event` is specified).\r\n\r\nFor a specific event:\r\n```javascript\r\nee.on(\"event\", function(){...});\r\nee.on(\"other-event\", function(){...});\r\nee.removeAllListeners(\"event\");\r\n\r\n// 1\r\nee.count(\"event\");\r\n```\r\nFor the whole `EventEmitter`:\r\n```javascript\r\nee.on(\"event\", function(){...});\r\nee.on(\"other-event\", function(){...});\r\nee.offAll();\r\n\r\n// 0\r\nee.count();\r\n```\r\n\r\n\r\n### #count/countListeners ([string: event (\"*\")])\r\n__event__: _string, optional (\"*\")_ The event for which to count the listeners. May contain wildcards.  \r\n__*return*__: *int* The amount of listener listening for `event`.\r\n\r\nThis method counts the listeners that are listening to `event` (which may contain wildcards; read the [Wildcards](#wildcards) section). If no `event` is specified, it counts all the listeners for the `EventEmitter`.\r\n\r\nFor a specific event:\r\n```javascript\r\nee.on(\"event\", function(){...});\r\nee.on(\"other-event\", function(){...});\r\n\r\n// 1\r\nee.count(\"event\");\r\n```\r\nFor the whole `EventEmitter`:\r\n```javascript\r\nee.on(\"event\", function(){...});\r\nee.on(\"other-event\", function(){...});\r\n\r\n// 2\r\nee.count();\r\n```\r\n\r\n\r\n### #listeners/getListeners ([string: event (\"*\")])\r\n__event__: _string, optional (\"*\")_. The event to get the listeners for. May contain wildcards.  \r\n__*return*__: *Array&lt;Listener&gt;*. An array containing all the listeners listening for `event`.\r\n\r\nThis method retrieves all the listeners that listen for `event` (which may contain wildcards; read the [Wildcards](#wildcards) section). If no `event` is specified, it returns all the listeners bound to the `EventEmitter`. The returned array may contain duplicates (if you added a listener more than once).\r\n\r\nFor a specific `event`:\r\n```javascript\r\nee.on(\"event\", function listener1(){...});\r\nee.on(\"other-event\", function listener2(){...});\r\n\r\n// [ function listener1(){...} ]\r\nee.listener(\"event\");\r\n```\r\nFor the whole `EventEmitter`:\r\n```javascript\r\nee.on(\"event\", function listener1(){...});\r\nee.on(\"other-event\", function listener2(){...});\r\n\r\n// [ function listener1(){...}, function listener2(){...} ]\r\nee.listeners();\r\n```\r\n\r\n\r\n### #namespace (string: scope)\r\n__scope__: *string* The name of the scope.\r\n\r\nUse the `namespace` method to create a scoped emitter. Read [.Namespace](#namespace-eventemitter-emitter-string-scope) for more info.\r\n\r\n```javascript\r\nvar n = ee.namespace(\"scope\");\r\nn.emit(\"event\");\r\n\r\n//emits the 'scope:event' event on ee.\r\n```\r\n\r\n\r\n### .Namespace (EventEmitter: emitter, string: scope)\r\n__emitter__: *EventEmitter* The EventEmitter on which to emit (scoped) events.\r\n__scope__: *string* The name of the scope.\r\n\r\nA Namespace emits events prefixed by `<scope>:`. It has the same API as EventEmitter, but it doesn't inherit from it, so it emits events on its parent (`emitter`), scoped like this: `<scope>:event`.\r\n\r\n```javascript\r\nvar namespace = new EventEmitter.Namespace(ee, \"scope\");\r\nnamespace.emit(\"event\");\r\n\r\n//emits the 'scope:event' event on ee.\r\n```\r\n\r\n\r\n### .execListener (Listener: listener, Array&lt;any&gt;: args)\r\n__listener__: *Listener* The listener to execute.  \r\n__args__: *Array&lt;any&gt;* The arguments to pass to the listener  \r\n__*return*__: *any*. Anything the listener returns.\r\n\r\n__Note__: This method is only available on the `EventEmitter` object, not on its instances!\r\n\r\n`EventEmitter.execListener()` executes a listener, `apply()`ing `args` to it.  \r\n`listener` can be a function, or an object with a `handleEvent()` method. For more info about listeners, check the [Listeners](#listeners) section.\r\nThe `this` in the listener will be set to `listener` (be it a function or an object; this is default javascript behaviour). This method is intended for internal use, but may be used publicly.\r\n\r\n```javascript\r\nvar listener = function(arg1, arg2){\r\n    console.log(arg1 + \", \" + arg2);\r\n    console.log(this);\r\n}\r\nvar objectListener = {\r\n    handleEvent: listener\r\n}\r\nvar args = [\"hello\", \"world\"];\r\n\r\n//hello, world\r\n//function\r\nEventEmitter.execListener(listener, [\"hello\", \"world\"]);\r\n\r\n//hello, world\r\n//object\r\nEventEmitter.execListener(objectListener, [\"hello\", \"world\"]);\r\n```\r\n\r\n\r\n### .eventRegexp (string: event)\r\n__event__: *string*. The event name to convert to a RegExp.  \r\n__*return*__: *RegExp*. The RegExp that matches the event name.\r\n\r\n__Note__: This method is only available on the `EventEmitter` object, not on its instances!\r\n\r\nWith `EventEmitter.eventRegexp()`, you can get the RegExp representation of a wildcard event. This method just passes the event name you give it to `new RegExp(event)`, after replacing `*` by `.*`. This method is intended for internal use, but may be used publicly.  \r\nThis method uses the `EventEmitter.regexps` object as a sort of cache: any event strings that have not yet passed `eventRegexp()` will be added to it (with their RegExp representation), and `EventRegexp()` will return the RegExp that has been stored in `regexps` if the event string can be found there.\r\n\r\n__Note__: When matching wildcard events with other wildcard events, weird things can happen. I'm working on a way to solve this. In the meantime, take a look at the [Wildcards](#wildcards) section.\r\n\r\n```javascript\r\n// /scope:.*/\r\nEventEmitter.eventRegexp(\"scope:*\");\r\n// Matches: \"scope:event\", \"scope:other-event\"\r\n// but not: \"event\", \"world:event\"\r\n```\r\n\r\n\r\n### .regexps | Object\r\n\r\n__Note__: This property is only available on the `EventEmitter` object, not on its instances!\r\n\r\n`EventEmitter.regexps` is an object matching event strings and their RegExp representations. This is only used by `EventEmitter.eventRegexp()` as a sort of cache, to prevent memoty leaks.\r\n\r\nIt looks like this:\r\n\r\n```javascript\r\nEventEmitter.regexps = {\r\n    \"event\": /^event$/,\r\n    \"scope:*\": /^scope:.*$\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## License\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014-2015 Tuur Dutoit\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[jasmine]: http://jasmine.github.io/\r\n[requirejs]: http://requirejs.org/\r\n[node.js]: http://nodejs.org/\r\n[GitHub]: https://github.com/TuurDutoit/EventEmitter/\r\n[npm]: https://www.npmjs.com/package/last-eventemitter\r\n[npm-home]: https://www.npmjs.com/\r\n[bower-home]: http://bower.io/\r\n[component-home]: https://github.com/componentjs/component\r\n[handleEvent]: https://developer.mozilla.org/en/docs/Web/API/EventTarget.addEventListener\r\n[issue tracker]: https://github.com/TuurDutoit/EventEmitter/issues\r\n","google":"UA-62013657-2","note":"Don't delete this file! It's used internally to help with page regeneration."}